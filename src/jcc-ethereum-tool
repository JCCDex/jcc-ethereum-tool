#!/usr/bin/env node

const program = require("commander");
const fs = require("fs");
const BigNumber = require("bignumber.js");
const utils = require("jcc-ethereum-utils");
const Keystore = require("./jcc-ethereum-keystore");
// const SolidityFunction = require("chain3/lib/chain3/function");
const ethers = require("ethers");
const abiCoder = ethers.utils.defaultAbiCoder;
const eth_ens_namehash = require('eth-ens-namehash');
const { create2ContractAddress } = require("web3-eth-contract");

function getBaseHome() {
  return (process.env.HOME || process.env.USERPROFILE) + "/.jcc-ethereum-tool";
}

program.version("0.0.10");
program.usage("--help", "Show ethereum-tools help");

let _description = "ETH command line tools";
program.description(_description);

program.option("--config <config file>", "specified config file, defaut is " + getBaseHome() + "/config.json");

program.option("--wallet_create", "Create new ETH wallet");
program.option("--save_wallet", "save wallet to keystore file when create");
program.option("--import_private_to_keystore", "import private key to keystore file");
program.option("--keystore <keystore file>", "keystore file path");
program.option("--password <keystore file password>", "keystore password");

program.option("--network <network id>", "specified ETH network id, mainnet is 99, testnet is 101");
program.option("--server <ETH node address>", "node rpc address");

program.option("--block <block number>", "get block info by number or latest");
program.option("--transaction <hash>", "get transaction by hash");
program.option("--traceTransaction <hash>", "trace transactions by transaction hash");
program.option("--receipt <hash>", "get transaction receipt by hash");

program.option("--balance <Wallet address>", "get balance of address");
program.option("--transfer <Destination address>", "destination address, source address specified by keystore or config");
program.option("--transferheco <Destination address>", "destination address, source address specified by keystore or config");
program.option("--amount <amount>", "transfer amount");
program.option("--legacy", "use with --transfer to send legacy transactions");

program.option("--deploy <contract json file>", "deploy contract, if have parameter, set it in --parameters");
program.option("--deploy2 <factory contract json file>", "deploy contract of using create2, if have parameter, set it in --parameters");

program.option("--nonce <number>", "specified nonce");
program.option("--getNonce", "get current nonce");
program.option("--gas_price <number>", "specified gasPrice, default 10000000000");
program.option("--gas_limit <number>", "specified gas limit, default 50000");
program.option("--maxFeePerGas <number>", "specified gasPrice, default 10000000000");
program.option("--maxPriorityFeePerGas <number>", "specified gasPrice, default 10000000000");

program.option("--erc20 <string>", "erc20 address");
program.option("--erc721 <string>", "erc721 address");
program.option("--fingate <string>", "fingate address");

program.option("--abi <contract json file>", "abi definition");
program.option("--contractAddr <contract address>", "contract address");

program.option("--method <string>", "specified contract method name");
program.option("--parameters <string>", "specified contract parameters which seprator by |");
program.option("--salt <string>", "specified salt");
program.option("--generateCreate2Addr <contract json file>", "generate create2 contract address");
program.option("--encodeCallData <contract json file>", "encoding calling contract method data");

program.parse(process.argv);


if (program.wallet_create) {
  if (!program.save_wallet) {
    Keystore.processCreateWallet();
  }

  Keystore.saveKeystore();

  return;
}

if (program.import_private_to_keystore) {
  Keystore.importToKeystore();
  return;
}

function getNetwork(_network) {
  let isNumber = !isNaN(Number(_network));
  _network = isNumber ? Number(_network) : _network;
  let type = typeof _network;
  if (type === "number") {
    _options.network = _network;
  }
  if (type === "string") {
    _options.network = _network.toLowerCase() === "main" ? 1 : 3;
  }
}

// 获取配置文件
let _config = program.config;
let _options = { network: 3 };

// 如果文件位置没有通过参数传递
if (!!!_config) {
  _config = getBaseHome() + "/config.json";
}
if (_config.indexOf("/") == -1 && _config.indexOf("\\") == -1) {
  if (_config.indexOf("json") == -1) {
    _config = getBaseHome() + "/config." + _config + ".json";
  }
}
if (!fs.existsSync(_config)) {
  console.log("can not get", _config, "file, create it manula!");
  process.exit();
}

// 读取文件
try {
  _options = Object.assign(_options, JSON.parse(fs.readFileSync(_config, "utf-8")));
  if (!_options.gasLimit) {
    _options.gasLimit = 50000;
  }
  if (!_options.gasPrice) {
    // 10G
    _options.gasPrice = 10000000000;
  }
  if (!_options.maxFeePerGas) {
    _options.maxFeePerGas = 10000000000;
  }
  if (!_options.maxPriorityFeePerGas) {
    _options.maxPriorityFeePerGas = 1000000000;
  }
} catch (e) {
  console.log("Parse config file fail, check and correct it", e);
  process.exit();
}

getNetwork(program.network);

if (program.keystore) {
  let keystorePath = program.keystore;
  // 兼容windows下的路径
  if (keystorePath.indexOf("/") == -1 && keystorePath.indexOf("\\") == -1) {
    keystorePath = getBaseHome() + "/" + keystorePath;
  }
  _options.wallet = Object.assign(_options.wallet, Keystore.getWalletFromKeystore(keystorePath, program.password));
}

if (!isNaN(Number(program.gas_limit))) {
  _options.gasLimit = Number(program.gas_limit);
}
if (!isNaN(Number(program.gas_price))) {
  _options.gasPrice = Number(program.gas_price);
}
if (!isNaN(Number(program.maxFeePerGas))) {
  _options.maxFeePerGas = Number(program.maxFeePerGas);
}
if (!isNaN(Number(program.maxPriorityFeePerGas))) {
  _options.maxPriorityFeePerGas = Number(program.maxPriorityFeePerGas);
}
if (!!program.server) {
  _options.server = program.server;
}

async function getBalance() {
  let balance = await inst.getBalance(program.balance);
  console.log("balance:", balance);
}
async function getCurrentNonce(address) {
  let nonce = await inst.getNonce(address);
  console.log("current nonce:", nonce.toString());
}

async function getGasPrice() {
  if (!_options.gasPrice) {
    _options.gasPrice = await inst.getGasPrice();
  }
  return _options.gasPrice;
}

async function getFeeData() {
  let feeData = {};
  if (!_options.maxFeePerGas || !_options.maxPriorityFeePerGas) {
    feeData = await inst.getFeeData();
    _options.maxFeePerGas = _options.maxFeePerGas || feeData.maxFeePerGas;
    _options.maxPriorityFeePerGas = _options.maxPriorityFeePerGas || feeData.maxPriorityFeePerGas;
  }
  return {
    maxFeePerGas: _options.maxFeePerGas,
    maxPriorityFeePerGas: _options.maxPriorityFeePerGas
  }
}

async function getBlock(block) {
  let info = await inst.getBlock(block);
  console.log("block:", JSON.stringify(info, (key, value) => {
    if (typeof value == "bigint") {
      return value.toString();
    } else {
      return value;
    }
  }, 2));
}

async function getTransaction(hash) {
  let info = await inst.getTransaction(hash);
  console.log("transaction:", JSON.stringify(info, (key, value) => {
    if (typeof value == "bigint") {
      return value.toString();
    } else {
      return value;
    }
  }, 2));
}

async function rpc_getTraceTransaction(hash) {
  return new Promise((resolve, reject) => {
    inst.getWeb3().currentProvider.send({
      id: 1,
      jsonrpc: "2.0",
      method: "debug_traceTransaction",
      params: [hash, {"tracer": "callTracer"}]
    }, (err, res) => {
      if (err) {
        return reject(err);
      }
      if (res.error) {
        return reject(res.error);
      }
      return resolve(res.result);
    });
  })
}

async function getTraceTransaction(hash) {
  const info = await rpc_getTraceTransaction(hash)
  console.log("trace transaction", JSON.stringify(info, (key, value) => {
    if (typeof value == "bigint") {
      return value.toString();
    } else {
      return value;
    }
  }, 2));
}

async function getTransactionReceipt(hash) {
  let info = await inst.getTransactionReceipt(hash);
  console.log("transaction receipt:", JSON.stringify(info, (key, value) => {
    if (typeof value == "bigint") {
      return value.toString();
    } else {
      return value;
    }
  }, 2));
}
async function getNonce(address) {
  if (!program.nonce) {
    let n = await inst.getNonce(_options.wallet.address);
    return n;
  }
  return program.nonce;
}
async function transfer(dest, amount) {
  let nonce = await getNonce(_options.wallet.address);
  let tx;
  if(program.legacy) {
    let gasPrice = await getGasPrice();
    tx = inst.getTx(_options.wallet.address, dest, nonce, _options.gasLimit, gasPrice, amount.toString(), "");
  } else {
    let feeData = await getFeeData();
    tx = inst.get1559Tx(_options.wallet.address, dest, nonce, _options.gasLimit, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas, amount.toString(), "");
  }
  console.log("tx:", tx, "raw:", await inst.signTransaction(tx, _options.wallet.secret));

  let hash = await inst.sendSignedTransaction(await inst.signTransaction(tx, _options.wallet.secret));
  console.log("transfer hash:", hash);
  process.exit(0);
}

async function transferheco(dest, amount) {
  // let nonce = await getNonce(_options.wallet.address);
  // let gasPrice = await getGasPrice();
  // let tx = inst.getTx(_options.wallet.address, dest, nonce, _options.gasLimit, gasPrice, amount, "");
  // let hash = await inst.sendSignedTransaction(inst.signTransaction(tx, _options.wallet.secret));
  // console.log("transfer hash:", hash);
  process.exit(0);
}

const sleep = (milliseconds) => {
  return new Promise((resolve) => setTimeout(resolve, milliseconds));
};

function getFile(filename) {
  if (!fs.existsSync(filename)) {
    filename = __dirname + "/" + filename;
    if (!fs.existsSync(filename)) {
      console.log("can not find ", filename);
      process.exit();
    }
  }
  try {
    return JSON.parse(fs.readFileSync(filename, "utf-8"));
  } catch (e) {
    console.log("get file ", filename, "error", e);
    process.exit(-1);
  }
}

async function deploy(compiledJson) {
  const calldata = await encodeCallData(compiledJson, "constructor");

  let nonce = await getNonce(_options.wallet.address);
  let tx;
  if(program.legacy) {
    let gasPrice = await getGasPrice();
    tx = inst.getTx(_options.wallet.address, null, nonce, _options.gasLimit, gasPrice, "0", calldata);
  } else {
    let feeData = await getFeeData();
    tx = inst.get1559Tx(_options.wallet.address, null, nonce, _options.gasLimit, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas, "0", calldata);
  }
  let signed = await inst.signTransaction(tx, _options.wallet.secret);
  let hash;
  try {
    hash = await inst.sendSignedTransaction(signed);
  } catch (e) {
    console.log(e);
    process.exit(-1);
  }
  console.log("create contract transaction hash:", hash);
  console.log("waiting for contract address.......");
  for (var i = 0; i < 20; i++) {
    await sleep(2000);
    let receipt = await inst.getTransactionReceipt(hash);
    if (receipt && receipt.contractAddress) {
      console.log("create contract", receipt.status ? "success" : "fail", "\ncontract address:", receipt.contractAddress);
      process.exit(0);
      return;
    }
  }

  console.log("can not get contract address, try get transaction receipt later");
}

function generateCreate2Addr(compiledJson, salt) {
  const send_address = _options.wallet.address;
  console.log("send address:", send_address);
  salt = inst._web3.eth.abi.encodeParameters([ "uint256" ], eval("[" + salt + "]"));
  console.log("salt:", salt);
  let _json = getFile(compiledJson);
  if (!_json.bytecode) {
    console.log("can not get byte code");
    process.exit(-1);
  }

  let abi = _json.abi;
  let constructor = abi.find((item) => item.type == "constructor");
  if (!constructor) {
    console.log("Can not find constructor in file", compiledJson, ", Please check it!");
  }
  if (constructor.inputs.length > 0 && !program.parameters) {
    console.log("miss --parameter arguments");
    process.exit();
  }
  let initCode;
  if (constructor.inputs.length == 0) {
    program.parameters = [];
    initCode = _json.bytecode;
  } else {
    const typename = constructor.inputs.map((input) => input.type);
    initCode = _json.bytecode + utils.Ethereum.filter0x(inst._web3.eth.abi.encodeParameters(typename, eval("[" + program.parameters + "]")));
  }
  if (initCode.indexOf("0x") != 0) {
    initCode = "0x" + initCode;
  }
  console.log("init code:", initCode);

  return create2ContractAddress("0xA922bFa9C833C6d8B664EbFAaa5AEAB434DfA8B6", salt, initCode);
}

async function encodeCallData(compiledJson, method) {
  let _json = getFile(compiledJson);
  let abi = _json.abi;
  if (!abi) {
    console.log("Can not find abi in file", compiledJson, ", Please check it!");
    process.exit();
  }
  if (method == "constructor") {
    let bytecode = _json.bytecode;
    if (!bytecode) {
      console.log("Can not find bytecode in file", compiledJson, ", Please check it!");
      process.exit();
    }
    let constructor = abi.find((item) => item.type == "constructor");
    if (!constructor) {
      console.log("Can not find constructor in file", compiledJson, ", Please check it!");
      process.exit();
    }
    if (constructor.inputs.length > 0 && !program.parameters) {
      console.log("miss --parameter arguments");
      process.exit();
    }

    let calldata;
    if (constructor.inputs.length == 0) {
      program.parameters = [];
      calldata = _json.bytecode;
    } else {
      const typename = constructor.inputs.map((input) => input.type);
      calldata = _json.bytecode + utils.Ethereum.filter0x(inst._web3.eth.abi.encodeParameters(typename, eval("[" + program.parameters + "]")));
    }
    if (calldata.indexOf("0x") != 0) {
      calldata = "0x" + calldata;
    }
    return calldata;
  }
  let sc = new utils.smartContract();
  sc.init(program.contractAddr, inst, abi);
  args = eval("[" + program.parameters + "]");
  return await sc._ethereumABI.encode.apply(null, [method, ...args]);
}

async function deploy2(compiledJson) {
  let method = program.method;
  let contractAddr = program.contractAddr;
  const calldata = await encodeCallData(compiledJson, method);
  
  let nonce = await getNonce(_options.wallet.address);
  let tx;
  if(program.legacy) {
    let gasPrice = await getGasPrice();
    tx = inst.getTx(_options.wallet.address, contractAddr, nonce, _options.gasLimit, gasPrice, "0", calldata);
  } else {
    let feeData = await getFeeData();
    tx = inst.get1559Tx(_options.wallet.address, contractAddr, nonce, _options.gasLimit, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas, "0", calldata);
  }

  let signed = await inst.signTransaction(tx, _options.wallet.secret);
  let hash;
  try {
    hash = await inst.sendSignedTransaction(signed);
  } catch (e) {
    console.log(e);
    process.exit(-1);
  }

  console.log("create contract transaction hash:", hash);
  console.log("waiting for contract address.......");
  for (var i = 0; i < 20; i++) {
    await sleep(2000);
    try {
      let trace = await rpc_getTraceTransaction("0x1d8d2b88f83fc21920947fb77d76298943d97b7724dd7e6378eba608fe8bb169");
      if (trace) {
        const calls = trace.calls;
        create2_call = calls.find((call) => call.type.toLowerCase() == "create2");
        const contractAddr = create2_call.to;
        console.log("create contract", trace ? "success" : "fail", "\ncontract address:", contractAddr);
        process.exit(0);
      }
    } catch (error) {
      if (error.code == -32601) {
        break;
      } 
    }
  }
  console.log("If you can't get the contract address, you can try tracking the transaction or checking it in the browser in the future");
}

// 初始化连接
let inst = new utils.Ethereum(_options.server, _options.network == 1);
inst.initWeb3();

if (program.block) {
  getBlock(program.block);
  return;
}

if (program.transaction) {
  getTransaction(program.transaction);
  return;
}

if (program.traceTransaction) {
    getTraceTransaction(program.traceTransaction).catch((err) => {
      console.error(err);
    })
    return;
}

if (program.receipt) {
  getTransactionReceipt(program.receipt);
  return;
}

if (program.deploy) {
  deploy(program.deploy);
  return;
}

if (program.balance) {
  getBalance();
  return;
}

if (program.getNonce) {
  getCurrentNonce(_options.wallet.address);
  return;
}
if (program.transfer) {
  var amount = Number(program.amount);
  if (isNaN(amount)) {
    console.log("amount is", program.amount, "invalid");
    process.exit();
  }
  transfer(program.transfer, amount);
  return;
}
if (program.transferheco) {
  var amount = Number(program.amount);
  if (isNaN(amount)) {
    console.log("amount is", program.amount, "invalid");
    process.exit();
  }
  transferheco(program.transferheco, amount);
  return;
}

if (program.generateCreate2Addr) {
  if (!program.salt) {
    console.log("Please specify salt");
    process.exit();
  }
  if (!program.parameters) {
    program.parameters = "";
  }

  const address = generateCreate2Addr(program.generateCreate2Addr, program.salt);
  console.log("create2 contract address:", address);
  return;
}

if (program.encodeCallData) {
  if (!program.method || (program.method != "constructor" && !program.contractAddr)) {
    console.log("Please specify method, if method is not constructor, contract address is also required");
    process.exit();
  }
  if (!program.parameters) {
    program.parameters = "";
  }

  encodeCallData(program.encodeCallData, program.method).then((res) => {
    console.log("call data:", res);
  });
  return;
}

if (program.deploy2) {
  deploy2(program.deploy2);
  return;
}

function getMethodCall() {
  if (!program.parameters) {
    return 'sc.callABI("' + program.method + '")';
  }
  return 'sc.callABI("' + program.method + '",' + program.parameters + ")";
}

async function callContract() {
  let _json = getFile(program.abi);
  let abi = _json.abi;
  let sc = new utils.smartContract();
  sc.init(program.contractAddr, inst, abi);
  // 该变量是为用户在外部传入chain3的函数调用 eval(getMethodCall()) 时用的
  let web3 = inst._web3
  let namehash = eth_ens_namehash.hash

  // 确定接口类型
  const abiItem = abi.find((item) => item.name == program.method);
  if (!abiItem) {
    console.log("Can not find method", program.method, "in abi definition.");
    process.exit();
  }
  const { stateMutability } = abiItem;
  if (stateMutability === "view" || stateMutability === "pure") {
    const byte = await eval(getMethodCall());
    console.log("return value:", byte);
  } else {
    const calldata = await eval(getMethodCall());
    let amount = "0";
    if (program.amount) {
      amount = program.amount + "";
    }
    if (!!program.nonce) {
      _options.nonce = program.nonce;
    } else {
      _options.nonce = await getNonce(_options.wallet.address);
    }

    let tx;
    if(program.legacy) {
      let gasPrice = await getGasPrice();
      tx = inst.getTx(_options.wallet.address, program.contractAddr, _options.nonce, _options.gasLimit, gasPrice, amount, calldata);
    } else {
      let feeData = await getFeeData();
      tx = inst.get1559Tx(_options.wallet.address, program.contractAddr, _options.nonce, _options.gasLimit, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas, amount, calldata);
    }
    console.log("tx:", tx);

    let signed = await inst.signTransaction(tx, _options.wallet.secret);
    console.log("signed:", signed);

    const hash = await inst.sendSignedTransaction(signed);
    console.log("hash:", hash);

    process.exit(0);
  }
}

if (program.abi) {
  if (!program.contractAddr || !program.method) {
    console.log("Please specify contract address, method and parameters");
    process.exit();
  }
  if (!program.parameters) {
    program.parameters = "";
  }

  callContract();
  return;
}
