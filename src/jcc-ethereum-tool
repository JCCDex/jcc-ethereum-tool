#!/usr/bin/env node

const { program } = require("commander");
const fs = require("fs");
const BigNumber = require("bignumber.js");
const utils = require("jcc-ethereum-utils");
const Keystore = require("./jcc-ethereum-keystore");
// const SolidityFunction = require("chain3/lib/chain3/function");
const eth_ens_namehash = require('eth-ens-namehash');
const { create2ContractAddress } = require("web3-eth-contract");
const packageJson = require("../package.json");

function getBaseHome() {
  return (process.env.HOME || process.env.USERPROFILE) + "/.jcc-ethereum-tool";
}

// program.version("0.0.10");
program.version(packageJson.version, '-v, --version', 'Output the current version');
program.usage("--help", "Show ethereum-tools help");

let _description = "ETH command line tools";
program.description(_description);

program.option("--config <config file>", "specified config file, defaut is " + getBaseHome() + "/config.json");

program.option("--wallet_create", "Create new ETH wallet");
program.option("--save_wallet", "save wallet to keystore file when create");
program.option("--import_private_to_keystore", "import private key to keystore file");
program.option("--keystore <keystore file>", "keystore file path");
program.option("--password <keystore file password>", "keystore password");

program.option("--network <network id>", "specified ETH network id, mainnet is 99, testnet is 101");
program.option("--server <ETH node address>", "node rpc address");

program.option("--block <block number>", "get block info by number or latest");
program.option("--transaction <hash>", "get transaction by hash");
program.option("--traceTransaction <hash>", "trace transactions by transaction hash");
program.option("--receipt <hash>", "get transaction receipt by hash");

program.option("--balance <Wallet address>", "get balance of address");
program.option("--transfer <Destination address>", "destination address, source address specified by keystore or config");
program.option("--transferheco <Destination address>", "destination address, source address specified by keystore or config");
program.option("--amount <amount>", "transfer amount");

program.option("--deploy <contract json file>", "deploy contract, if have parameter, set it in --parameters");
program.option("--deploy2 <factory contract json file>", "deploy contract of using create2, if have parameter, set it in --parameters");

program.option("--nonce <number>", "specified nonce");
program.option("--getNonce", "get current nonce");
program.option("--gas_price <number>", "specified gasPrice, default 10000000000");
program.option("--gas_limit <number>", "specified gas limit, default 50000");
program.option("--maxFeePerGas <number>", "specified gasPrice");
program.option("--maxPriorityFeePerGas <number>", "specified gasPrice");

program.option("--erc20 <string>", "erc20 address");
program.option("--erc721 <string>", "erc721 address");
program.option("--fingate <string>", "fingate address");

program.option("--abi <contract json file>", "abi definition");
program.option("--contractAddr <contract address>", "contract address");

program.option("--method <string>", "specified contract method name");
program.option("--parameters <parameter...>", "specified contract parameters which seprator by |");
program.option("--salt <string>", "specified salt, byte32");
program.option("--generateCreate2Addr <contract json file>", "generate create2 contract address, --contractAddr (deployer) and --salt is required");
program.option("--encodeCallData <contract json file>", "encoding calling contract method data");

program.parse(process.argv);

const options = program.opts();

if (options.wallet_create) {
  if (!options.save_wallet) {
    Keystore.processCreateWallet();
  }

  Keystore.saveKeystore();

  return;
}

if (options.import_private_to_keystore) {
  Keystore.importToKeystore();
  return;
}

function getNetwork(_network) {
  let isNumber = !isNaN(Number(_network));
  _network = isNumber ? Number(_network) : _network;
  let type = typeof _network;
  if (type === "number") {
    _options.network = _network;
  }
  if (type === "string") {
    _options.network = _network.toLowerCase() === "main" ? 1 : 3;
  }
}

// 获取配置文件
let _config = options.config;
let _options = { network: 3 };

// 如果文件位置没有通过参数传递
if (!!!_config) {
  _config = getBaseHome() + "/config.json";
}
if (_config.indexOf("/") == -1 && _config.indexOf("\\") == -1) {
  if (_config.indexOf("json") == -1) {
    _config = getBaseHome() + "/config." + _config + ".json";
  }
}
if (!fs.existsSync(_config)) {
  console.log("can not get", _config, "file, create it manula!");
  process.exit();
}

// 读取文件
try {
  _options = Object.assign(_options, JSON.parse(fs.readFileSync(_config, "utf-8")));
  if (!_options.gasLimit) {
    _options.gasLimit = 50000;
  }
  if (!_options.gasPrice) {
    // 10G
    _options.gasPrice = 10000000000;
  }
} catch (e) {
  console.log("Parse config file fail, check and correct it", e);
  process.exit();
}

getNetwork(options.network);

if (options.keystore) {
  let keystorePath = options.keystore;
  // 兼容windows下的路径
  if (keystorePath.indexOf("/") == -1 && keystorePath.indexOf("\\") == -1) {
    keystorePath = getBaseHome() + "/" + keystorePath;
  }
  _options.wallet = Object.assign(_options.wallet, Keystore.getWalletFromKeystore(keystorePath, options.password));
}

if (!isNaN(Number(options.gas_limit))) {
  _options.gasLimit = Number(options.gas_limit);
}
if (!isNaN(Number(options.gas_price))) {
  _options.gasPrice = Number(options.gas_price);
}
if (!isNaN(Number(options.maxFeePerGas))) {
  _options.maxFeePerGas = Number(options.maxFeePerGas);
}
if (!isNaN(Number(options.maxPriorityFeePerGas))) {
  _options.maxPriorityFeePerGas = Number(options.maxPriorityFeePerGas);
}
if (!!options.server) {
  _options.server = options.server;
}
if (!options.parameters) {
  options.parameters = [];
}

function parseArgs(args) {
  return args.map((arg) => {
    try {
      if ((arg.startsWith("{") && arg.endsWith("}")) || (arg.startsWith("[") && arg.endsWith("]"))) {
        return JSON.parse(arg);
      }
      return arg;
    } catch (error) {
      return arg;
    }
  })
}

async function getBalance(address) {
  let balance = await inst.getBalance(address);
  console.log("balance:", balance);
}
async function getCurrentNonce(address) {
  let nonce = await inst.getNonce(address);
  console.log("current nonce:", nonce.toString());
}

async function getGasPrice() {
  if (!_options.gasPrice) {
    _options.gasPrice = await inst.getGasPrice();
  }
  return _options.gasPrice;
}

async function getFeeData() {
  let feeData = {};
  if (!_options.maxFeePerGas || !_options.maxPriorityFeePerGas) {
    feeData = await inst.getFeeData();
    _options.maxFeePerGas = _options.maxFeePerGas || feeData.maxFeePerGas;
    _options.maxPriorityFeePerGas = _options.maxPriorityFeePerGas || feeData.maxPriorityFeePerGas;
  }
  return {
    maxFeePerGas: _options.maxFeePerGas,
    maxPriorityFeePerGas: _options.maxPriorityFeePerGas
  }
}

function customReplacer(key, value) {
  if (typeof value === "bigint") {
    return value.toString();
  } else {
    return value;
  }
}

async function getBlock(block) {
  let info = await inst.getBlock(block);
  console.log("block:", JSON.stringify(info, customReplacer, 2));
}

async function getTransaction(hash) {
  let info = await inst.getTransaction(hash);
  console.log("transaction:", JSON.stringify(info, customReplacer, 2));
}

async function rpc_getTraceTransaction(hash) {
  return new Promise((resolve, reject) => {
    inst.getWeb3().currentProvider.send({
      id: 1,
      jsonrpc: "2.0",
      method: "debug_traceTransaction",
      params: [hash, {"tracer": "callTracer"}]
    }, (err, res) => {
      if (err) {
        return reject(err);
      }
      if (res.error) {
        return reject(res.error);
      }
      return resolve(res.result);
    });
  })
}

async function getTraceTransaction(hash) {
  const info = await rpc_getTraceTransaction(hash).catch((err) => {
    console.error(err);
    process.exit(-1);
  })
  console.log("trace transaction", JSON.stringify(info, customReplacer, 2));
}

async function getTransactionReceipt(hash) {
  let info = await inst.getTransactionReceipt(hash);
  console.log("transaction receipt:", JSON.stringify(info, customReplacer, 2));
}
async function getNonce(address) {
  if (!program.nonce) {
    let n = await inst.getNonce(_options.wallet.address);
    return n;
  }
  return program.nonce;
}

async function getTx(dest, amount, nonce, calldata) {
  let latestBlock = await inst.getBlock("latest");
  const baseFeePerGas = latestBlock.baseFeePerGas;
  let tx;
  if(baseFeePerGas) {
    let feeData = await getFeeData();
    tx = inst.get1559Tx(_options.wallet.address, dest, nonce, _options.gasLimit, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas, amount.toString(), calldata);
  } else {
    let gasPrice = await getGasPrice();
    tx = inst.getTx(_options.wallet.address, dest, nonce, _options.gasLimit, gasPrice, amount.toString(), calldata);
  }
  return tx;
}

async function transfer(dest, amount) {
  let nonce = await getNonce(_options.wallet.address);
  const tx = await getTx(dest, amount, nonce, "");
  console.log("tx:", tx, "raw:", await inst.signTransaction(tx, _options.wallet.secret));

  let hash = await inst.sendSignedTransaction(await inst.signTransaction(tx, _options.wallet.secret));
  console.log("transfer hash:", hash);
  process.exit(0);
}

async function transferheco(dest, amount) {
  // let nonce = await getNonce(_options.wallet.address);
  // let gasPrice = await getGasPrice();
  // let tx = inst.getTx(_options.wallet.address, dest, nonce, _options.gasLimit, gasPrice, amount, "");
  // let hash = await inst.sendSignedTransaction(inst.signTransaction(tx, _options.wallet.secret));
  // console.log("transfer hash:", hash);
  process.exit(0);
}

const sleep = (milliseconds) => {
  return new Promise((resolve) => setTimeout(resolve, milliseconds));
};

function getFile(filename) {
  if (!fs.existsSync(filename)) {
    filename = __dirname + "/" + filename;
    if (!fs.existsSync(filename)) {
      console.log("can not find ", filename);
      process.exit();
    }
  }
  try {
    return JSON.parse(fs.readFileSync(filename, "utf-8"));
  } catch (e) {
    console.log("get file ", filename, "error", e);
    process.exit(-1);
  }
}

async function deploy(compiledJson, parameters) {
  const calldata = await encodeCallData(compiledJson, "constructor", parameters);
  let nonce = await getNonce(_options.wallet.address);
  let tx = await getTx(null, 0, nonce, calldata);
  let signed = await inst.signTransaction(tx, _options.wallet.secret);
  let hash;
  try {
    hash = await inst.sendSignedTransaction(signed);
  } catch (e) {
    console.log(e);
    process.exit(-1);
  }
  console.log("create contract transaction hash:", hash);
  console.log("waiting for contract address.......");
  for (var i = 0; i < 20; i++) {
    await sleep(2000);
    let receipt = await inst.getTransactionReceipt(hash);
    if (receipt && receipt.contractAddress) {
      console.log("create contract", receipt.status ? "success" : "fail", "\ncontract address:", receipt.contractAddress);
      process.exit(0);
      return;
    }
  }

  console.log("can not get contract address, try get transaction receipt later");
}

function generateCreate2Addr(compiledJson, contractAddr, salt, parameters) {
  console.log("creator address:", contractAddr);
  salt = inst._web3.utils.encodePacked({
    type: "bytes32",
    value: salt
  })
  console.log("salt:", salt);
  let _json = getFile(compiledJson);
  if (!_json.bytecode) {
    console.log("can not get byte code");
    process.exit(-1);
  }

  let abi = _json.abi;
  let constructor = abi.find((item) => item.type == "constructor");
  if (!constructor) {
    console.log("Can not find constructor in file", compiledJson, ", Please check it!");
  }
  if (constructor.inputs.length > 0 && parameters.length == 0) {
    console.log("miss --parameter arguments");
    process.exit();
  }
  let initCode;
  if (constructor.inputs.length == 0) {
    initCode = _json.bytecode;
  } else {
    const typename = constructor.inputs.map((input) => input.type);
    const args = parseArgs(parameters);
    initCode = _json.bytecode + utils.Ethereum.filter0x(inst._web3.eth.abi.encodeParameters(typename, args));
  }
  if (initCode.indexOf("0x") != 0) {
    initCode = "0x" + initCode;
  }
  console.log("init code:", initCode);

  return create2ContractAddress(contractAddr, salt, initCode);
}

async function encodeCallData(compiledJson, method, parameters) {
  let _json = getFile(compiledJson);
  let abi = _json.abi;
  let bytecode = _json.bytecode;
  if (!abi) {
    console.log("Can not find abi in file", compiledJson, ", Please check it!");
    process.exit();
  }
  let sc = new utils.smartContract();
  sc.init(null, inst, abi);
  args = parseArgs(parameters);
  if (method == "constructor") {
    let constructor = abi.find((item) => item.type == "constructor");
    if (!constructor) {
      return bytecode;
    }
    if (constructor.inputs.length > 0 && parameters.length == 0) {
      console.log("miss --parameter arguments");
      process.exit();
    }
    return sc._contract.deploy({ data: "0x" + bytecode, arguments: args }).encodeABI();
  }
  return await sc._contract.methods[method].apply(null, args).encodeABI();
}

async function deploy2(compiledJson, contractAddr, method, parameters) {
  const calldata = await encodeCallData(compiledJson, method, parameters);
  
  let nonce = await getNonce(_options.wallet.address);
  let tx = await getTx(contractAddr, 0, nonce, calldata);

  let signed = await inst.signTransaction(tx, _options.wallet.secret);
  let hash;
  try {
    hash = await inst.sendSignedTransaction(signed);
  } catch (e) {
    console.log(e);
    process.exit(-1);
  }

  console.log("create contract transaction hash:", hash);
  console.log("waiting for contract address.......");
  for (var i = 0; i < 20; i++) {
    await sleep(2000);
    try {
      let trace = await rpc_getTraceTransaction(hash);
      if (trace) {
        const calls = trace.calls;
        create2_call = calls.find((call) => call.type.toLowerCase() == "create2");
        const contractAddr = create2_call.to;
        console.log("create contract", trace ? "success" : "fail", "\ncontract address:", contractAddr);
        process.exit(0);
      }
    } catch (error) {
      if (error.code == -32601) {
        break;
      } 
    }
  }
  console.log("If you can't get the contract address, you can try tracking the transaction or checking it in the browser in the future");
}

// 初始化连接
let inst = new utils.Ethereum(_options.server, _options.network == 1);
inst.initWeb3();

if (options.block) {
  getBlock(options.block);
  return;
}

if (options.transaction) {
  getTransaction(options.transaction);
  return;
}

if (options.traceTransaction) {
    getTraceTransaction(options.traceTransaction);
    return;
}

if (options.receipt) {
  getTransactionReceipt(options.receipt);
  return;
}

if (options.deploy) {
  deploy(options.deploy, options.parameters);
  return;
}

if (options.balance) {
  getBalance(options.balance);
  return;
}

if (options.getNonce) {
  getCurrentNonce(_options.wallet.address);
  return;
}
if (options.transfer) {
  var amount = Number(options.amount);
  if (isNaN(amount)) {
    console.log("amount is", options.amount, "invalid");
    process.exit();
  }
  transfer(options.transfer, amount);
  return;
}
if (options.transferheco) {
  var amount = Number(options.amount);
  if (isNaN(amount)) {
    console.log("amount is", options.amount, "invalid");
    process.exit();
  }
  transferheco(options.transferheco, amount);
  return;
}

if (options.generateCreate2Addr) {
  if (!options.contractAddr || !options.salt) {
    console.log("Please specify contract address and salt");
    process.exit();
  }

  const address = generateCreate2Addr(options.generateCreate2Addr, options.contractAddr, options.salt, options.parameters);
  console.log("create2 contract address:", address);
  return;
}

if (options.encodeCallData) {
  if (!options.method) {
    console.log("Please specify method");
    process.exit();
  }

  encodeCallData(options.encodeCallData, options.method, options.parameters).then((res) => {
    console.log("call data:", res);
  });
  return;
}

if (options.deploy2) {
  deploy2(options.deploy2, options.contractAddr, options.method, options.parameters);
  return;
}

function getMethodCall(method, parameters) {
  if (parameters.length == 0) {
    return 'sc.callABI("' + method + '")';
  }
  return 'sc.callABI("' + method + '",' + parameters + ")";
}

async function callContract(abiJson, contractAddr, method, parameters, nonce) {
  let _json = getFile(abiJson);
  let abi = _json.abi;
  let sc = new utils.smartContract();
  sc.init(contractAddr, inst, abi);
  // 该变量是为用户在外部传入chain3的函数调用 eval(getMethodCall()) 时用的
  let web3 = inst._web3
  let namehash = eth_ens_namehash.hash

  // 确定接口类型
  const abiItem = abi.find((item) => item.name == method);
  if (!abiItem) {
    console.log("Can not find method", method, "in abi definition.");
    process.exit();
  }
  const { stateMutability } = abiItem;
  if (stateMutability === "view" || stateMutability === "pure") {
    const byte = await sc.callABI(method, ...parameters);
    console.log("return value:", byte);
  } else {
    const calldata = await sc.callABI(method, ...parameters);
    let amount = "0";
    if (amount) {
      amount = amount + "";
    }
    if (!!nonce) {
      _options.nonce = nonce;
    } else {
      _options.nonce = await getNonce(_options.wallet.address);
    }

    let tx = await getTx(contractAddr, amount, _options.nonce, calldata);
    console.log("tx:", tx);

    let signed = await inst.signTransaction(tx, _options.wallet.secret);
    console.log("signed:", signed);

    const hash = await inst.sendSignedTransaction(signed);
    console.log("hash:", hash);

    process.exit(0);
  }
}

if (options.abi) {
  if (!options.contractAddr || !options.method) {
    console.log("Please specify contract address, method and parameters");
    process.exit();
  }

  callContract(options.abi, options.contractAddr, options.method, options.parameters, options.nonce);
  return;
}
